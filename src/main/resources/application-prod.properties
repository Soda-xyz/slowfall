# Production settings: TLS is terminated by the upstream reverse proxy (nginx proxy in App Service).
# Disable server-side SSL in the backend container when TLS is terminated by the proxy.
server.ssl.enabled=false
server.port=${PORT:8080}

# Production cookie settings (secure=true, sameSite=None when using cross-site cookies over TLS)
app.security.cookie-secure=true
app.security.cookie-name=refresh_token
app.security.cookie-same-site=None
# Configure allowed CORS origins for production. When using credentialed requests
app.cors.allowed-origins=${ALLOWED_ORIGINS}
# Also populate spring.cors.allowed-origins so the CorsConfig which reads
# spring.cors.allowed-origins (no fallbacks) will work in production.
spring.cors.allowed-origins=${ALLOWED_ORIGINS}

# Database postgresql
spring.datasource.url=${SPRING_DATASOURCE_URL}
spring.datasource.driver-class-name=org.postgresql.Driver
spring.datasource.hikari.maximum-pool-size=20
spring.flyway.enabled=true
spring.flyway.locations=classpath:db/migration
spring.h2.console.enabled=false
spring.jpa.hibernate.ddl-auto=none

# Explicit database platform to avoid Hibernate failing to infer Dialect when JDBC metadata
# is unavailable at startup. The production environment should still provide SPRING_DATASOURCE_URL
# (e.g. via environment variables / Azure App Settings). Setting the dialect here ensures
# Hibernate can initialize when the URL is provided via the environment or container.
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect

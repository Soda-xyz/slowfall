name: CI / Build / Publish / Deploy

on:
  push:
    branches:
      - "**"
  pull_request:
    branches:
      - "**"
  workflow_dispatch:
    inputs:
      frontend_env:
        description: "Frontend build mode (development or production)"
        required: false
        default: "production"

permissions:
  contents: read
  packages: write
  id-token: write

env:
  REGISTRY: ghcr.io
  ALLOWED_ORIGINS: ${{ secrets.ALLOWED_ORIGINS }}
  VITE_API_BASE_URL: ""

jobs:
  build-and-test:
    name: Build & Test (backend + frontend)
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure Gradle wrapper is executable
        run: chmod +x ./gradlew
        shell: bash

      - name: Set up JDK 21 (Temurin)
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: '21'
          cache: 'gradle'

      - name: Cache Gradle packages
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
            .gradle
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties', '**/settings.gradle*', '**/build.gradle*', '**/build.gradle.kts') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: Build & test backend (Gradle)
        working-directory: ./
        run: |
          ./gradlew --no-daemon clean test

      - name: Set up Node 20
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package.json

      - name: Install frontend dependencies
        run: npm ci --prefix frontend

      - name: Lint frontend
        run: npm --prefix frontend run lint --if-present

      - name: Test frontend
        run: npm --prefix frontend run test --if-present

      - name: Build frontend
        env:
          VITE_FRONTEND_ENV: ${{ github.event.inputs.frontend_env || 'production' }}
          VITE_API_BASE_URL: ${{ ((github.event.inputs.frontend_env || 'production') == 'development') && 'http://localhost:8080' || '' }}
        run: npm --prefix frontend run build -- --mode $VITE_FRONTEND_ENV

      - name: Install brotli (for asset checks)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update -y
          sudo apt-get install -y brotli

      - name: 'CI assertion: ensure frontend build didn''t bake /api/api'
        run: |
          set -euo pipefail
          found=0
          if ls frontend/dist/*.js frontend/dist/**/*.js >/dev/null 2>&1; then
            if grep -R --line-number --binary-files=without-match "/api/api" frontend/dist/*.js frontend/dist/**/*.js 2>/dev/null; then
              echo "ERROR: '/api/api' found in built assets"
              found=1
            fi
          fi
          if [ "$found" -ne 0 ]; then
            exit 1
          fi

      - name: Upload build artifacts (optional)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist
          path: frontend/dist

  frontend-docker-checks:
    name: Frontend Docker checks (nginx test)
    runs-on: ubuntu-latest
    needs: build-and-test
    env:
      BACKEND_FQDN: ${{ secrets.BACKEND_APP_NAME }}.azurewebsites.net

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up QEMU and Buildx
        uses: docker/setup-buildx-action@v3

      - name: Compute sanitized BACKEND_FQDN for CI checks
        id: sanitize_backend
        run: |
          set -euo pipefail
          RAW="${{ secrets.BACKEND_APP_NAME }}"
          SANITIZED=$(echo "$RAW" | tr -d '\r\n ')
          if echo "$SANITIZED" | grep -q '\.'; then
            FQDN="$SANITIZED"
          else
            FQDN="$SANITIZED.azurewebsites.net"
          fi
          echo "BACKEND_FQDN=$FQDN" >> "$GITHUB_ENV"

      - name: Build frontend image (load into local Docker)
        uses: docker/build-push-action@v4
        with:
          context: .
          file: docker/frontend/Dockerfile
          push: false
          load: true
          tags: |
            slowfall-frontend:ci
          build-args: |
            VITE_FRONTEND_ENV=${{ (secrets.DEPLOY_ENV == 'prod' || secrets.DEPLOY_ENV == 'production') && 'production' || secrets.DEPLOY_ENV || github.event.inputs.frontend_env || 'production' }}
            VITE_API_BASE_URL=${{ (secrets.DEPLOY_ENV == 'development' || github.event.inputs.frontend_env == 'development') && 'http://localhost:8080' || '' }}
            BACKEND_HOST=${{ env.BACKEND_FQDN }}

      - name: nginx config syntax test inside image
        run: |
          docker run --rm --add-host ${BACKEND_FQDN}:127.0.0.1 --add-host backend:127.0.0.1 --entrypoint nginx slowfall-frontend:ci -t

      - name: Ensure index.html exists in image
        run: docker run --rm slowfall-frontend:ci sh -c 'test -f /usr/share/nginx/html/index.html'

      - name: Start container in background and curl root
        run: |
          set -euo pipefail
          docker run -d --add-host ${BACKEND_FQDN}:127.0.0.1 --add-host backend:127.0.0.1 --name slowfall-frontend-ci -p 127.0.0.1:8080:80 slowfall-frontend:ci || true
          sleep 3
          if ! curl -fsS --max-time 5 http://127.0.0.1:8080/ | head -c 200 >/tmp/frontend_curl.out; then
            exit 1
          fi

      - name: Cleanup container and image (always)
        if: always()
        run: |
          docker rm -f slowfall-frontend-ci >/dev/null 2>&1 || true
          docker image rm slowfall-frontend:ci >/dev/null 2>&1 || true

  publish-images:
    name: Build & Publish images (GHCR)
    needs: frontend-docker-checks
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    outputs:
      owner: ${{ steps.normalize_owner.outputs.owner }}
      owner_lower: ${{ steps.normalize_owner.outputs.owner_lower }}
      spring_profile: ${{ steps.compute_spring_profile.outputs.spring_profile }}

    steps:
      - name: Normalize repository owner to lowercase
        id: normalize_owner
        run: |
          OWNER="${{ github.repository_owner }}"
          LOWER=$(echo "$OWNER" | tr '[:upper:]' '[:lower:]')
          # Emit both the original owner (preserve case) and a lowercase variant
          echo "owner=$OWNER" >> "$GITHUB_OUTPUT"
          echo "owner_lower=$LOWER" >> "$GITHUB_OUTPUT"

      - name: Checkout
        uses: actions/checkout@v4

      - name: Login to GitHub Container Registry (GHCR)
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Compute sanitized BACKEND_FQDN for publish
        id: sanitize_backend_publish
        run: |
          set -euo pipefail
          RAW="${{ secrets.BACKEND_APP_NAME }}"
          SANITIZED=$(echo "$RAW" | tr -d '\r\n ')
          if echo "$SANITIZED" | grep -q '\.'; then
            FQDN="$SANITIZED"
          else
            FQDN="$SANITIZED.azurewebsites.net"
          fi

      - name: Azure login (OIDC) for resolving backend FQDN
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Set backend App Service allowed-group app setting from secret
        run: |
          set -euo pipefail
          az webapp config appsettings set \
            --name "${{ secrets.BACKEND_APP_NAME }}" \
            --resource-group "${{ secrets.AZURE_RG }}" \
            --settings "APP_SECURITY_ALLOWED_GROUP_ID=${{ secrets.SLOWFALL_WEB_USERS_GROUP_ID }}"

      - name: Resolve backend defaultHostName (use as BACKEND_FQDN)
        run: |
          set -euo pipefail
          RAW_NAME="${{ secrets.BACKEND_APP_NAME }}"
          RG="${{ secrets.AZURE_RG }}"
          FQDN=$(az webapp show --name "$RAW_NAME" --resource-group "$RG" --query defaultHostName -o tsv)
          echo "BACKEND_FQDN=$FQDN" >> "$GITHUB_ENV"

      - name: Compute SPRING_PROFILE from DEPLOY_ENV secret
        id: compute_spring_profile
        run: |
          set -euo pipefail
          DEPLOY="${{ secrets.DEPLOY_ENV || '' }}"
          if [ -z "$DEPLOY" ]; then
            echo "ERROR: Repository secret DEPLOY_ENV is not set."
            exit 1
          fi
          case "$DEPLOY" in
            production|prod)
              SPRING_PROFILE="prod"
              ;;
            development|dev)
              SPRING_PROFILE="dev"
              ;;
            *)
              SPRING_PROFILE="$DEPLOY"
              ;;
          esac
          echo "SPRING_PROFILE=$SPRING_PROFILE" >> "$GITHUB_ENV"
          echo "spring_profile=$SPRING_PROFILE" >> "$GITHUB_OUTPUT"

      - name: Build & push backend image
        id: build_backend
        uses: docker/build-push-action@v4
        with:
          context: .
          file: docker/backend/Dockerfile
          push: true
          platforms: linux/amd64
          tags: |
            ${{ env.REGISTRY }}/${{ steps.normalize_owner.outputs.owner_lower }}/slowfall-backend:${{ github.sha }}
            ${{ env.REGISTRY }}/${{ steps.normalize_owner.outputs.owner_lower }}/slowfall-backend:latest
          build-args: |
            SPRING_PROFILES_ACTIVE=${{ env.SPRING_PROFILE }}

      - name: Verify backend image pushed
        run: |
          set -euo pipefail
          IMAGE="${{ env.REGISTRY }}/${{ steps.normalize_owner.outputs.owner_lower }}/slowfall-backend:${{ github.sha }}"
          echo "Verifying pushed backend image: $IMAGE"
          # Prefer digest returned by docker build-push action
          DIGEST="${{ steps.build_backend.outputs.digest || '' }}"
          if [ -n "$DIGEST" ]; then
            echo "Detected backend digest from build action: $DIGEST"
            echo "BACKEND_IMAGE_DIGEST=$DIGEST" >> "$GITHUB_ENV"
          else
            # Fallback: try pulling the image and inspect RepoDigest
            docker pull "$IMAGE"
            docker image inspect "$IMAGE" >/dev/null
            DIGEST=$(docker image inspect --format='{{index .RepoDigests 0}}' "$IMAGE" || true)
            if [ -n "$DIGEST" ]; then
              echo "Detected backend digest by inspect: $DIGEST"
              echo "BACKEND_IMAGE_DIGEST=$DIGEST" >> "$GITHUB_ENV"
            else
              echo "No RepoDigest found for $IMAGE, will fall back to tag."
              echo "BACKEND_IMAGE_TAG=$IMAGE" >> "$GITHUB_ENV"
            fi
          fi
          echo "Backend image verified: $IMAGE"

      - name: Build & push frontend image
        id: build_frontend
        uses: docker/build-push-action@v4
        with:
          context: .
          file: docker/frontend/Dockerfile
          push: true
          platforms: linux/amd64
          tags: |
            ${{ env.REGISTRY }}/${{ steps.normalize_owner.outputs.owner_lower }}/slowfall-frontend:${{ github.sha }}
            ${{ env.REGISTRY }}/${{ steps.normalize_owner.outputs.owner_lower }}/slowfall-frontend:latest
          build-args: |
            VITE_FRONTEND_ENV=${{ env.SPRING_PROFILE == 'prod' && 'production' || env.SPRING_PROFILE }}
            VITE_API_BASE_URL=${{ env.SPRING_PROFILE == 'dev' && 'http://localhost:8080' || '' }}
            BACKEND_HOST=${{ env.BACKEND_FQDN }}

      - name: Verify frontend image pushed
        run: |
          set -euo pipefail
          IMAGE="${{ env.REGISTRY }}/${{ steps.normalize_owner.outputs.owner_lower }}/slowfall-frontend:${{ github.sha }}"
          echo "Verifying pushed frontend image: $IMAGE"
          DIGEST="${{ steps.build_frontend.outputs.digest || '' }}"
          if [ -n "$DIGEST" ]; then
            echo "Detected frontend digest from build action: $DIGEST"
            echo "FRONTEND_IMAGE_DIGEST=$DIGEST" >> "$GITHUB_ENV"
          else
            docker pull "$IMAGE"
            docker image inspect "$IMAGE" >/dev/null
            DIGEST=$(docker image inspect --format='{{index .RepoDigests 0}}' "$IMAGE" || true)
            if [ -n "$DIGEST" ]; then
              echo "Detected frontend digest by inspect: $DIGEST"
              echo "FRONTEND_IMAGE_DIGEST=$DIGEST" >> "$GITHUB_ENV"
            else
              echo "No RepoDigest found for $IMAGE, will fall back to tag."
              echo "FRONTEND_IMAGE_TAG=$IMAGE" >> "$GITHUB_ENV"
            fi
          fi
          echo "Frontend image verified: $IMAGE"

      - name: Build & push proxy image
        id: build_proxy
        uses: docker/build-push-action@v4
        with:
          context: .
          file: docker/nginx/Dockerfile
          push: true
          platforms: linux/amd64
          tags: |
            ${{ env.REGISTRY }}/${{ steps.normalize_owner.outputs.owner_lower }}/slowfall-proxy:${{ github.sha }}
            ${{ env.REGISTRY }}/${{ steps.normalize_owner.outputs.owner_lower }}/slowfall-proxy:latest
          build-args: |
            BACKEND_HOST=${{ env.BACKEND_FQDN }}

      - name: Verify proxy image pushed
        run: |
          set -euo pipefail
          IMAGE="${{ env.REGISTRY }}/${{ steps.normalize_owner.outputs.owner_lower }}/slowfall-proxy:${{ github.sha }}"
          echo "Verifying pushed proxy image: $IMAGE"
          DIGEST="${{ steps.build_proxy.outputs.digest || '' }}"
          if [ -n "$DIGEST" ]; then
            echo "Detected proxy digest from build action: $DIGEST"
            echo "PROXY_IMAGE_DIGEST=$DIGEST" >> "$GITHUB_ENV"
          else
            docker pull "$IMAGE"
            docker image inspect "$IMAGE" >/dev/null
            DIGEST=$(docker image inspect --format='{{index .RepoDigests 0}}' "$IMAGE" || true)
            if [ -n "$DIGEST" ]; then
              echo "Detected proxy digest by inspect: $DIGEST"
              echo "PROXY_IMAGE_DIGEST=$DIGEST" >> "$GITHUB_ENV"
            else
              echo "No RepoDigest found for $IMAGE, will fall back to tag."
              echo "PROXY_IMAGE_TAG=$IMAGE" >> "$GITHUB_ENV"
            fi
          fi
          echo "Proxy image verified: $IMAGE"

      - name: Set app settings (SPRING_PROFILES_ACTIVE and ALLOWED_ORIGINS) on Backend & Frontend
        run: |
          set -euo pipefail
          SETTINGS=()
          if [ -n "${SPRING_PROFILE:-}" ]; then
            SETTINGS+=("SPRING_PROFILES_ACTIVE=${SPRING_PROFILE}")
          fi
          SETTINGS+=("ALLOWED_ORIGINS=${{ secrets.ALLOWED_ORIGINS }}")

          # Ensure Key Vault settings are propagated to the backend (and frontend when relevant).
          # These are provided as repository secrets and must be set in the environment.
          # The backend expects APP_SECURITY_AZURE_KEYVAULT_VAULT_URL and APP_SECURITY_AZURE_KEYVAULT_KEY_NAME
          # so that SecurityConfig can create/load the RSAKey bean at startup.
          SETTINGS+=("APP_SECURITY_AZURE_KEYVAULT_VAULT_URL=${{ secrets.APP_SECURITY_AZURE_KEYVAULT_VAULT_URL }}")
          SETTINGS+=("APP_SECURITY_AZURE_KEYVAULT_KEY_NAME=${{ secrets.APP_SECURITY_AZURE_KEYVAULT_KEY_NAME }}")

          # Enable verbose logging for troubleshooting in production temporarily
          if [ "${SPRING_PROFILE:-}" = "prod" ]; then
            SETTINGS+=("DEBUG=true")
            SETTINGS+=("LOGGING_LEVEL_ROOT=DEBUG")
          fi

          az webapp config appsettings set --name "${{ secrets.BACKEND_APP_NAME }}" --resource-group "${{ secrets.AZURE_RG }}" --settings "${SETTINGS[@]}"
          az webapp config appsettings set --name "${{ secrets.FRONTEND_APP_NAME }}" --resource-group "${{ secrets.AZURE_RG }}" --settings "${SETTINGS[@]}"

      - name: Set app settings on proxy
        run: |
          PROXY_NAME="${{ secrets.PROXY_APP_NAME || 'slowfall-proxy' }}"
          if [ -n "${BACKEND_FQDN:-}" ]; then
            BACKEND_HOST_VAL="${BACKEND_FQDN}"
          else
            BACKEND_HOST_VAL="${{ secrets.BACKEND_APP_NAME }}.azurewebsites.net"
          fi
          # Require APP_SECURITY_AZURE_KEYVAULT_VAULT_URL to be set as a secret (do not fall back to a hardcoded vault URI)
          az webapp config appsettings set --name "$PROXY_NAME" --resource-group "${{ secrets.AZURE_RG }}" --settings \
            WEBSITES_PORT=80 BACKEND_HOST="$BACKEND_HOST_VAL" BACKEND_PORT=8080 CLIENT_MAX_BODY_SIZE=20m PROXY_READ_TIMEOUT=90s PROXY_SEND_TIMEOUT=90s APP_SECURITY_AZURE_KEYVAULT_VAULT_URL="${{ secrets.APP_SECURITY_AZURE_KEYVAULT_VAULT_URL }}"

      - name: Set backend container image
        run: |
          set -euo pipefail
          APP="${{ secrets.BACKEND_APP_NAME }}"
          RG="${{ secrets.AZURE_RG }}"
          OWNER_LOWER="${{ needs.publish-images.outputs.owner_lower }}"

          # Prefer an immutable digest if available, otherwise use the tag
          if [ -n "${BACKEND_IMAGE_DIGEST:-}" ]; then
            DIG="${BACKEND_IMAGE_DIGEST}"
            # DIG may be either 'ghcr.io/owner/repo@sha256:...' or just 'sha256:...'
            if echo "$DIG" | grep -q '@'; then
              IMAGE_VALUE="$DIG"
            else
              # assume bare sha like 'sha256:...'
              IMAGE_VALUE="${{ env.REGISTRY }}/${OWNER_LOWER}/slowfall-backend@${DIG}"
            fi
          else
            IMAGE_VALUE="${BACKEND_IMAGE_TAG:-${{ env.REGISTRY }}/${{ needs.publish-images.outputs.owner_lower }}/slowfall-backend:${{ github.sha }}}"
          fi

          echo "Setting container image for $APP -> $IMAGE_VALUE"
          az webapp config container set --name "$APP" --resource-group "$RG" --container-image-name "$IMAGE_VALUE"

          # Poll until siteConfig.linuxFxVersion reflects the expected image
          echo "Waiting up to 120s for $APP to reflect container image..."
          current=""
          for i in $(seq 1 24); do
            current=$(az webapp show --name "$APP" --resource-group "$RG" --query 'siteConfig.linuxFxVersion' -o tsv || echo "")
            if [ "$current" = "DOCKER|$IMAGE_VALUE" ] || [ "$current" = "$IMAGE_VALUE" ]; then
              echo "Container config updated for $APP"
              break
            fi
            echo "Waiting ($i/24): current='$current' expected='DOCKER|$IMAGE_VALUE'"
            sleep 5
          done
          if [ "$current" != "DOCKER|$IMAGE_VALUE" ] && [ "$current" != "$IMAGE_VALUE" ]; then
            echo "ERROR: container config for $APP did not update to expected image within timeout. Current='$current' Expected='DOCKER|$IMAGE_VALUE' or '$IMAGE_VALUE'"
            exit 1
          fi

      - name: Set frontend container image
        run: |
          set -euo pipefail
          APP="${{ secrets.FRONTEND_APP_NAME }}"
          RG="${{ secrets.AZURE_RG }}"
          OWNER_LOWER="${{ needs.publish-images.outputs.owner_lower }}"

          if [ -n "${FRONTEND_IMAGE_DIGEST:-}" ]; then
            DIG="${FRONTEND_IMAGE_DIGEST}"
            if echo "$DIG" | grep -q '@'; then
              IMAGE_VALUE="$DIG"
            else
              IMAGE_VALUE="${{ env.REGISTRY }}/${OWNER_LOWER}/slowfall-frontend@${DIG}"
            fi
          else
            IMAGE_VALUE="${FRONTEND_IMAGE_TAG:-${{ env.REGISTRY }}/${{ needs.publish-images.outputs.owner_lower }}/slowfall-frontend:${{ github.sha }}}"
          fi

          echo "Setting container image for $APP -> $IMAGE_VALUE"
          az webapp config container set --name "$APP" --resource-group "$RG" --container-image-name "$IMAGE_VALUE"

          # Poll until siteConfig.linuxFxVersion reflects the expected image
          echo "Waiting up to 120s for $APP to reflect container image..."
          current=""
          for i in $(seq 1 24); do
            current=$(az webapp show --name "$APP" --resource-group "$RG" --query 'siteConfig.linuxFxVersion' -o tsv || echo "")
            if [ "$current" = "DOCKER|$IMAGE_VALUE" ] || [ "$current" = "$IMAGE_VALUE" ]; then
              echo "Container config updated for $APP"
              break
            fi
            echo "Waiting ($i/24): current='$current' expected='DOCKER|$IMAGE_VALUE'"
            sleep 5
          done
          if [ "$current" != "DOCKER|$IMAGE_VALUE" ] && [ "$current" != "$IMAGE_VALUE" ]; then
            echo "ERROR: container config for $APP did not update to expected image within timeout. Current='$current' Expected='DOCKER|$IMAGE_VALUE' or '$IMAGE_VALUE'"
            exit 1
          fi

      - name: Set proxy container image
        run: |
          PROXY_NAME="${{ secrets.PROXY_APP_NAME || 'slowfall-proxy' }}"
          RG="${{ secrets.AZURE_RG }}"
          OWNER_LOWER="${{ needs.publish-images.outputs.owner_lower }}"

          if [ -n "${PROXY_IMAGE_DIGEST:-}" ]; then
            DIG="${PROXY_IMAGE_DIGEST}"
            if echo "$DIG" | grep -q '@'; then
              IMAGE_VALUE="$DIG"
            else
              IMAGE_VALUE="${{ env.REGISTRY }}/${OWNER_LOWER}/slowfall-proxy@${DIG}"
            fi
          else
            IMAGE_VALUE="${PROXY_IMAGE_TAG:-${{ env.REGISTRY }}/${{ needs.publish-images.outputs.owner_lower }}/slowfall-proxy:${{ github.sha }}}"
          fi

          echo "Setting container image for $PROXY_NAME -> $IMAGE_VALUE"
          az webapp config container set --name "$PROXY_NAME" --resource-group "$RG" --container-image-name "$IMAGE_VALUE"

      - name: Restart backend Web App
        run: az webapp restart --name "${{ secrets.BACKEND_APP_NAME }}" --resource-group "${{ secrets.AZURE_RG }}"

      - name: Restart frontend Web App
        run: az webapp restart --name "${{ secrets.FRONTEND_APP_NAME }}" --resource-group "${{ secrets.AZURE_RG }}"

      - name: Restart proxy Web App
        run: |
          PROXY_NAME="${{ secrets.PROXY_APP_NAME || 'slowfall-proxy' }}"
          az webapp restart --name "$PROXY_NAME" --resource-group "${{ secrets.AZURE_RG }}"

      - name: Wait for backend & frontend readiness (actuator or /)
        run: |
          set -euo pipefail
          BACKEND_HOST="${{ secrets.BACKEND_APP_NAME }}.azurewebsites.net"
          FRONTEND_HOST="${{ secrets.FRONTEND_APP_NAME }}.azurewebsites.net"

          check_url() {
            host="$1"
            for i in $(seq 1 60); do
              if curl -fsS --max-time 5 "https://$host/actuator/health" >/dev/null 2>&1; then
                echo "$host is healthy (actuator)"
                return 0
              fi
              if curl -fsS --max-time 5 "https://$host/" >/dev/null 2>&1; then
                echo "$host is responding on root /"
                return 0
              fi
              echo "Waiting for $host to be ready ($i/60)..."
              sleep 5
            done
            echo "ERROR: $host did not become healthy within timeout"
            return 1
          }

          check_url "$BACKEND_HOST"
          check_url "$FRONTEND_HOST"

# End of workflow

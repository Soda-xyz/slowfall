name: Minimal CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch: {}

permissions:
  contents: read
  packages: write
  id-token: write

env:
  REGISTRY: ${{ secrets.ACR_LOGIN_SERVER }}
  ALLOWED_ORIGINS: ${{ secrets.ALLOWED_ORIGINS }}
  VITE_API_BASE_URL: ""
  PSEUDO_AUTH_ENABLED: ${{ secrets.PSEUDO_AUTH_ENABLED }}

jobs:
  lint:
    name: Lint (frontend + backend style checks)
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node 20
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install frontend dependencies for lint
        run: npm ci --prefix frontend

      - name: Run frontend lint
        run: npm --prefix frontend run lint --if-present

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'

      - name: Run backend style checks (spotless / checkstyle)
        run: ./gradlew --no-daemon spotlessCheck check
        shell: bash

  backend-build-test:
    name: Backend Build & Test
    runs-on: ubuntu-latest
    needs: lint

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure Gradle wrapper is executable
        run: chmod +x ./gradlew
        shell: bash

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'
          cache: 'gradle'

      - name: Cache Gradle packages
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
            .gradle
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}

      - name: Build & test backend (production profile)
        # Run tests first without forcing production profile so test resources and H2 (dev) settings apply
        run: ./gradlew --no-daemon clean test
        shell: bash

      - name: Build backend artifact (production profile)
        env:
          SPRING_PROFILES_ACTIVE: prod
        run: ./gradlew --no-daemon assemble
        shell: bash

  frontend-build-and-upload:
    name: Frontend Build & Upload
    runs-on: ubuntu-latest
    needs: backend-build-test
    env:
      # Allow the job to read the CI deploy env (if present) so we can derive frontend mode when input is absent
      SPRING_PROFILES_ACTIVE: ${{ secrets.DEPLOY_ENV }}
    outputs:
      vite_frontend_env: ${{ steps.persist_frontend_mode.outputs.vite_frontend_env }}
      vite_api_base_url: ${{ steps.persist_frontend_mode.outputs.vite_api_base_url }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node 20
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: frontend/package.json

      - name: Install frontend dependencies
        run: npm ci --prefix frontend

      - name: Lint frontend
        run: npm --prefix frontend run lint --if-present

      - name: Test frontend
        run: npm --prefix frontend run test --if-present

      - name: Determine frontend mode
        id: persist_frontend_mode
        run: |
          set -euo pipefail
          # Prefer explicit workflow input, then DEPLOY_ENV from the job env
          FRONT_INPUT="${{ github.event.inputs.frontend_env || env.SPRING_PROFILES_ACTIVE || '' }}"
          if [ -z "$FRONT_INPUT" ]; then
            echo "ERROR: workflow input 'frontend_env' is not set and DEPLOY_ENV is not present; please provide explicit 'frontend_env' or set the DEPLOY_ENV secret" >&2
            exit 1
          fi
          case "$FRONT_INPUT" in
            prod)
              CHOSEN="production"
              ;;
            dev)
              CHOSEN="development"
              ;;
            production|development)
              CHOSEN="$FRONT_INPUT"
              ;;
            *)
              CHOSEN="$FRONT_INPUT"
              ;;
          esac
          echo "VITE_FRONTEND_ENV=$CHOSEN" >> "$GITHUB_ENV"
          if [ "$CHOSEN" = "development" ]; then
            echo "VITE_API_BASE_URL=http://localhost:8080" >> "$GITHUB_ENV"
          else
            echo "VITE_API_BASE_URL=" >> "$GITHUB_ENV"
          fi
          # Expose outputs for downstream jobs
          echo "vite_frontend_env=$CHOSEN" >> "$GITHUB_OUTPUT"
          if [ "$CHOSEN" = "development" ]; then
            echo "vite_api_base_url=http://localhost:8080" >> "$GITHUB_OUTPUT"
          else
            echo "vite_api_base_url=" >> "$GITHUB_OUTPUT"
          fi

      - name: Build frontend
        env:
          VITE_FRONTEND_ENV: ${{ steps.persist_frontend_mode.outputs.vite_frontend_env }}
        run: npm --prefix frontend run build -- --mode $VITE_FRONTEND_ENV
        continue-on-error: false

      - name: Install brotli (for asset checks)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update -y
          sudo apt-get install -y brotli

      - name: 'CI assertion: ensure frontend build didn''t bake /api/api'
        run: |
          set -euo pipefail
          found=0
          if ls frontend/dist/*.js frontend/dist/**/*.js >/dev/null 2>&1; then
            if grep -R --line-number --binary-files=without-match "/api/api" frontend/dist/*.js frontend/dist/**/*.js 2>/dev/null; then
              echo "ERROR: '/api/api' found in built assets"
              found=1
            fi
          fi
          if [ "$found" -ne 0 ]; then
            exit 1
          fi

      - name: Upload frontend artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist
          path: frontend/dist

  docker-build-push:
    name: Build and push Docker images to ACR
    runs-on: ubuntu-latest
    needs: [frontend-build-and-upload]
    if: github.ref == 'refs/heads/main'
    # Make SPRING_PROFILES_ACTIVE available in this job. The deploy environment is stored in the secret DEPLOY_ENV.
    env:
      # Use DEPLOY_ENV secret only; do not derive values from the branch automatically
      SPRING_PROFILES_ACTIVE: ${{ secrets.DEPLOY_ENV }}
      PSEUDO_AUTH_ENABLED: ${{ secrets.PSEUDO_AUTH_ENABLED }}
      PSEUDO_USER: ${{ secrets.PSEUDO_USER }}
      PSEUDO_PASS: ${{ secrets.PSEUDO_PASS }}
    outputs:
      spring_profiles_active: ${{ steps.compute_spring_profile.outputs.spring_profiles_active }}
      frontend_digest: ${{ steps.capture_frontend_digest.outputs.frontend_digest }}
      proxy_digest: ${{ steps.capture_proxy_digest.outputs.proxy_digest }}
      backend_digest: ${{ steps.capture_backend_digest.outputs.backend_digest }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Login to Azure (OIDC)
        uses: azure/login@v1
        with:
          client-id: 'f17c9149-9c99-4294-ada3-9a97f0cf7b0b'
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          enable-oidc: true

      - name: Login to ACR using az cli
        run: |
          # Use canonical ACR name from repository secrets (e.g. slowfallregistry)
          ACR_NAME="${{ secrets.ACR_NAME }}"
          echo "Logging in to ACR: $ACR_NAME"
          az acr login --name "$ACR_NAME"
        shell: bash

      - name: Build & push backend image
        id: build_backend
        uses: docker/build-push-action@v4
        with:
          context: .
          file: docker/backend/Dockerfile
          push: true
          tags: ${{ secrets.ACR_NAME }}.azurecr.io/slowfall-backend:${{ github.sha }}
          build-args: |
            SPRING_PROFILES_ACTIVE=prod

      - name: Build & push frontend image
        id: build_frontend
        uses: docker/build-push-action@v4
        with:
          context: .
          file: docker/frontend/Dockerfile
          push: true
          tags: ${{ secrets.ACR_NAME }}.azurecr.io/slowfall-frontend:${{ github.sha }}
          build-args: |
            VITE_FRONTEND_ENV=${{ steps.validate_frontend_mode.outputs.vite_frontend_env }}
            VITE_API_BASE_URL=${{ steps.validate_frontend_mode.outputs.vite_api_base_url }}
            BACKEND_HOST=${{ env.BACKEND_HOST }}

      - name: Capture frontend image digest for immutable deploy reference
        id: capture_frontend_digest
        run: |
          set -euo pipefail
          # Prefer the digest reported by the build action
          DIGEST="${{ steps.build_frontend.outputs.digest }}"
          if [ -z "$DIGEST" ]; then
            IMAGE="${{ secrets.ACR_NAME }}.azurecr.io/slowfall-frontend:${{ github.sha }}"
            echo "build action did not report digest; attempting to pull and inspect image: $IMAGE"
            # Try to pull the image and inspect repo digests
            docker pull "$IMAGE"
            DIGEST_FULL="$(docker image inspect "$IMAGE" --format '{{index .RepoDigests 0}}' 2>/dev/null || true)"
            if [ -n "$DIGEST_FULL" ]; then
              # DIGEST_FULL looks like '<registry>/repo@sha256:...'; extract part after '@'
              DIGEST="${DIGEST_FULL#*@}"
            fi
          fi
          if [ -z "$DIGEST" ]; then
            echo "ERROR: frontend build did not produce a digest output" >&2
            exit 1
          fi
          echo "frontend_digest=$DIGEST" >> "$GITHUB_OUTPUT"
        shell: bash

      - name: Capture backend image digest for immutable deploy reference
        id: capture_backend_digest
        run: |
          set -euo pipefail
          # Prefer the digest reported by the build action
          DIGEST="${{ steps.build_backend.outputs.digest }}"
          if [ -z "$DIGEST" ]; then
            IMAGE="${{ secrets.ACR_NAME }}.azurecr.io/slowfall-backend:${{ github.sha }}"
            echo "build action did not report digest; attempting to pull and inspect image: $IMAGE"
            docker pull "$IMAGE"
            DIGEST_FULL="$(docker image inspect "$IMAGE" --format '{{index .RepoDigests 0}}' 2>/dev/null || true)"
            if [ -n "$DIGEST_FULL" ]; then
              DIGEST="${DIGEST_FULL#*@}"
            fi
          fi
          if [ -z "$DIGEST" ]; then
            echo "ERROR: backend build did not produce a digest output" >&2
            exit 1
          fi
          echo "backend_digest=$DIGEST" >> "$GITHUB_OUTPUT"
        shell: bash

      - name: Build & push proxy image
        id: build_proxy
        uses: docker/build-push-action@v4
        with:
          context: .
          file: docker/nginx/Dockerfile
          push: true
          platforms: linux/amd64
          # Use canonical ACR name and commit SHA for immutable tagging (no fallbacks)
          tags: ${{ secrets.ACR_NAME }}.azurecr.io/slowfall-proxy:${{ github.sha }}
          build-args: |
            BACKEND_HOST=${{ env.BACKEND_HOST }}

      - name: Capture proxy image digest for immutable deploy reference
        id: capture_proxy_digest
        run: |
          set -euo pipefail
          DIGEST="${{ steps.build_proxy.outputs.digest }}"
          if [ -z "$DIGEST" ]; then
            echo "ERROR: proxy build did not produce a digest output"
            exit 1
          fi
          echo "proxy_digest=$DIGEST" >> "$GITHUB_OUTPUT"
        shell: bash

      - name: Verify proxy image pushed
        run: |
          set -euo pipefail
          # Use the exact image tag pushed above (no fallbacks)
          IMAGE_LATEST="${{ secrets.ACR_NAME }}.azurecr.io/slowfall-proxy:${{ github.sha }}"
          echo "Verifying pushed image: $IMAGE_LATEST"
          docker pull "$IMAGE_LATEST"
          docker image inspect "$IMAGE_LATEST" >/dev/null
          echo "Proxy image verified: $IMAGE_LATEST"

      - name: Set app settings (SPRING_PROFILES_ACTIVE and ALLOWED_ORIGINS) on Backend & Frontend
        run: |
          set -euo pipefail
          SETTINGS=()
          if [ -n "${SPRING_PROFILES_ACTIVE:-}" ]; then
          SETTINGS+=("SPRING_PROFILES_ACTIVE=${SPRING_PROFILES_ACTIVE}")
          fi
          SETTINGS+=("ALLOWED_ORIGINS=${{ secrets.ALLOWED_ORIGINS }}")

          SETTINGS+=("AZ_KEYVAULT_VAULT_URL=${{ secrets.AZ_KEYVAULT_VAULT_URL }}")
          SETTINGS+=("AZ_KEYVAULT_KEY_NAME=${{ secrets.AZ_KEYVAULT_KEY_NAME }}")

          BACKEND_SETTINGS=("${SETTINGS[@]}")
          FRONT_SETTINGS=("${SETTINGS[@]}")

          _tmp_front=()
          for s in "${FRONT_SETTINGS[@]}"; do
          k="${s%%=*}"
          if [ "$k" = "SPRING_PROFILES_ACTIVE" ]; then
           echo "Skipping frontend write of SPRING_PROFILES_ACTIVE"
           continue
          fi
          _tmp_front+=("$s")
          done
          FRONT_SETTINGS=("${_tmp_front[@]}")

          # Use job env variables instead of inline expression evaluation
          #          if [ "${PSEUDO_AUTH_ENABLED}" = "true" ]; then

          if [ "${PSEUDO_AUTH_ENABLED:-}" = "true" ]; then
            echo "Pseudo auth enabled: adding pseudo-related app settings"
            BACKEND_SETTINGS+=("PSEUDO_AUTH_ENABLED=true")
            BACKEND_SETTINGS+=("app.security.dev-username=${PSEUDO_USER}")
            BACKEND_SETTINGS+=("app.security.dev-password=${PSEUDO_PASS}")

            FRONT_SETTINGS+=("VITE_PSEUDO_AUTH=true")
            FRONT_SETTINGS+=("VITE_PSEUDO_USER=${PSEUDO_USER}")
            FRONT_SETTINGS+=("VITE_PSEUDO_PASS=${PSEUDO_PASS}")
            # Keep MSAL client/authority empty when using pseudo auth to avoid accidental real auth
            FRONT_SETTINGS+=("VITE_MSAL_CLIENT_ID=")
            FRONT_SETTINGS+=("VITE_MSAL_AUTHORITY=")
          fi

          # Optionally include a PORT setting if the secret APP_PORT is present
          if [ -n "${{ secrets.APP_PORT || '' }}" ]; then
          BACKEND_SETTINGS+=("PORT=${{ secrets.APP_PORT }}")
          fi

          # Apply the settings to the backend and frontend app services
          # Sanitize settings: only pass entries that contain an '=' character (valid key=value or key=)
          FILTERED_BACKEND=()
          FILTERED_FRONT=()
          FILTERED_BACKEND_KEYS=()
          FILTERED_FRONT_KEYS=()
          for s in "${BACKEND_SETTINGS[@]}"; do
            if [[ "$s" == *=* ]]; then
              FILTERED_BACKEND+=("$s")
              FILTERED_BACKEND_KEYS+=("${s%%=*}")
            else
              echo "Skipping invalid backend setting (no '=' found): $s" >&2
            fi
          done
          for s in "${FRONT_SETTINGS[@]}"; do
            if [[ "$s" == *=* ]]; then
              FILTERED_FRONT+=("$s")
              FILTERED_FRONT_KEYS+=("${s%%=*}")
            else
              echo "Skipping invalid frontend setting (no '=' found): $s" >&2
            fi
          done

          # Deduplicate entries while preserving order so last occurrence wins.
          # Build ordered key list and map for backend
          declare -A BACK_MAP
          declare -a BACK_ORDER
          declare -a DELETE_BACK_KEYS
          for s in "${FILTERED_BACKEND[@]}"; do
            k="${s%%=*}"
            v="${s#*=}"
            # remove existing occurrence of k in BACK_ORDER if present (so we can append and preserve last-occurrence order)
            for i in "${!BACK_ORDER[@]}"; do
              if [ "${BACK_ORDER[$i]}" = "$k" ]; then
                unset 'BACK_ORDER[$i]'
                break
              fi
            done
            # append key to order
            BACK_ORDER+=("$k")
            if [ -z "${v}" ]; then
              DELETE_BACK_KEYS+=("$k")
              unset BACK_MAP["$k"]
            else
              BACK_MAP["$k"]="$v"
            fi
          done
          # Build FINAL_BACK using BACK_ORDER to preserve final order and avoid duplicates
          declare -a FINAL_BACK
          declare -a FINAL_BACK_KEYS
          for k in "${BACK_ORDER[@]}"; do
            # skip keys that were marked for deletion
            if [ -z "${BACK_MAP[$k]+_}" ]; then
              continue
            fi
            FINAL_BACK+=("${k}=${BACK_MAP[$k]}")
            FINAL_BACK_KEYS+=("$k")
          done

          # Frontend: same logic
          declare -A FRONT_MAP
          declare -a FRONT_ORDER
          declare -a DELETE_FRONT_KEYS
          for s in "${FILTERED_FRONT[@]}"; do
            k="${s%%=*}"
            v="${s#*=}"
            for i in "${!FRONT_ORDER[@]}"; do
              if [ "${FRONT_ORDER[$i]}" = "$k" ]; then
                unset 'FRONT_ORDER[$i]'
                break
              fi
            done
            FRONT_ORDER+=("$k")
            if [ -z "${v}" ]; then
              DELETE_FRONT_KEYS+=("$k")
              unset FRONT_MAP["$k"]
            else
              FRONT_MAP["$k"]="$v"
            fi
          done
          declare -a FINAL_FRONT
          declare -a FINAL_FRONT_KEYS
          for k in "${FRONT_ORDER[@]}"; do
            if [ -z "${FRONT_MAP[$k]+_}" ]; then
              continue
            fi
            FINAL_FRONT+=("${k}=${FRONT_MAP[$k]}")
            FINAL_FRONT_KEYS+=("$k")
          done

          # Echo only the names of the final settings (avoid printing secret values)
          echo "Applying backend app settings: ${FINAL_BACK_KEYS[*]}"
          echo "Applying frontend app settings: ${FINAL_FRONT_KEYS[*]}"

          # Apply non-empty settings per-key to isolate failures and provide clearer logs
          if [ ${#FINAL_BACK[@]} -gt 0 ]; then
            echo "Setting backend app settings one-by-one"
            for entry in "${FINAL_BACK[@]}"; do
              key="${entry%%=*}"
              echo "Applying backend key: $key"
              out=$(az webapp config appsettings set --name "${{ secrets.BACKEND_APP_NAME }}" --resource-group "${{ secrets.AZURE_RG }}" --settings "$entry" 2>&1) || true
              rc=$?
              if [ $rc -ne 0 ]; then
                echo "ERROR - Failed to set backend setting for key $key"
                echo "az output -"
                echo "$out"
                 echo "Current backend app settings (keys only)"
                  az webapp config appsettings list --name "${{ secrets.BACKEND_APP_NAME }}" --resource-group "${{ secrets.AZURE_RG }}" -o json | jq -r '.[].name' || true
                   exit $rc
               fi
             done
           else
             echo "No backend app settings to set"
           fi

           if [ ${#FINAL_FRONT[@]} -gt 0 ]; then
             echo "Setting frontend app settings one-by-one"
             for entry in "${FINAL_FRONT[@]}"; do
               key="${entry%%=*}"
               echo "Applying frontend key: $key"
               out=$(az webapp config appsettings set --name "${{ secrets.FRONTEND_APP_NAME }}" --resource-group "${{ secrets.AZURE_RG }}" --settings "$entry" 2>&1) || true
               rc=$?
               if [ $rc -ne 0 ]; then
                 echo "ERROR - Failed to set frontend setting for key $key"
                 echo "az output -"
                 echo "$out"
                 echo "Current frontend app settings (keys only)"
                 az webapp config appsettings list --name "${{ secrets.FRONTEND_APP_NAME }}" --resource-group "${{ secrets.AZURE_RG }}" -o json | jq -r '.[].name' || true
                 exit $rc
               fi
             done
           else
             echo "No frontend app settings to set"
           fi


      - name: Set app settings on proxy
        run: |
          PROXY_NAME="${{ secrets.PROXY_APP_NAME || 'slowfall-proxy' }}"
          if [ -n "${BACKEND_HOST:-}" ]; then
            BACKEND_HOST_VAL="${BACKEND_HOST}"
          else
            BACKEND_HOST_VAL="${{ secrets.BACKEND_APP_NAME }}.azurewebsites.net"
          fi

          # Build settings array and pass as separate args to avoid embedding comments or empty lines
          SETTINGS=()
          SETTINGS+=("BACKEND_HOST=${BACKEND_HOST_VAL}")
          SETTINGS+=("CLIENT_MAX_BODY_SIZE=20m")
          SETTINGS+=("PROXY_READ_TIMEOUT=90s")
          SETTINGS+=("PROXY_SEND_TIMEOUT=90s")
          SETTINGS+=("AZ_KEYVAULT_VAULT_URL=${{ secrets.AZ_KEYVAULT_VAULT_URL }}")
          SETTINGS+=("AZ_KEYVAULT_KEY_NAME=${{ secrets.AZ_KEYVAULT_KEY_NAME }}")

          # Apply settings to the proxy app service
          set -euo pipefail
          echo "Setting proxy app settings: ${SETTINGS[*]}"
          az webapp config appsettings set --name "$PROXY_NAME" --resource-group "${{ secrets.AZURE_RG }}" --settings "${SETTINGS[@]}"

      - name: Update Web Apps to new image digests
        run: |
          set -euo pipefail
          ACR_HOST="${{ secrets.ACR_NAME }}.azurecr.io"

          FRONT_IMG="$ACR_HOST/slowfall-frontend@${{ steps.capture_frontend_digest.outputs.frontend_digest }}"
          BACK_IMG="$ACR_HOST/slowfall-backend@${{ steps.capture_backend_digest.outputs.backend_digest }}"
          PROXY_IMG="$ACR_HOST/slowfall-proxy@${{ steps.capture_proxy_digest.outputs.proxy_digest }}"

          echo "Updating frontend app to $FRONT_IMG"
          az webapp config container set \
            --name "${{ secrets.FRONTEND_APP_NAME }}" \
            --resource-group "${{ secrets.AZURE_RG }}" \
            --docker-custom-image-name "$FRONT_IMG" \
            --docker-registry-server-url "https://$ACR_HOST"

          echo "Updating backend app to $BACK_IMG"
          az webapp config container set \
            --name "${{ secrets.BACKEND_APP_NAME }}" \
            --resource-group "${{ secrets.AZURE_RG }}" \
            --docker-custom-image-name "$BACK_IMG" \
            --docker-registry-server-url "https://$ACR_HOST"

          echo "Updating proxy app to $PROXY_IMG"
          PROXY_NAME="${{ secrets.PROXY_APP_NAME || 'slowfall-proxy' }}"
          az webapp config container set \
            --name "$PROXY_NAME" \
            --resource-group "${{ secrets.AZURE_RG }}" \
            --docker-custom-image-name "$PROXY_IMG" \
            --docker-registry-server-url "https://$ACR_HOST"
        shell: bash
